# Load necessary libraries
library(dplyr)
library(tidyr)
library(ggplot2)
library(stargazer)
library(sandwich)   # For robust and clustered standard errors
library(lmtest)
library(lme4)
library(modelsummary)
library(tinytable)
library(rlang)
library(pandoc)
if (!requireNamespace("semPlot", quietly = TRUE)) install.packages("semPlot")
if (!requireNamespace("lavaan", quietly = TRUE)) install.packages("lavaan")
library(lavaan)
library(semPlot)
rm(list=ls())
path_github <-"C:/Users/DCCS2/Documents/GitHub/Multi-level-collective-action-in-small-scale-fisheries/Exptal Sessions/R/"
path_datos<-"C:/Users/DCCS2/Dropbox/CICS/Experiments/Islitas/Data/Sessions"
#path_github <-"C:/Users/Denise Laroze/Documents/GitHub/Multi-level-collective-action-in-small-scale-fisheries/Exptal Sessions/R/"
#path_datos<-"C:/Users/Denise Laroze/Dropbox/CICS/Experiments/Islitas/Data/Sessions"
setwd(path_github)
#load(paste0(path_datos, "/Datos_islitas.Rdata"))
load(paste0(path_datos, "/Datos_islitas_recode.Rdata"))
load(paste0(path_datos, "/Datos_islitas_long.Rdata"))
df_long_ext <- dfs_long %>%
pivot_longer(
cols = c(extraction_amerb, extraction_OA),
names_to = "area",
values_to = "extraction"
) %>%
mutate(
# simplify area labels
area = recode(
area,
extraction_amerb = "TURF",
extraction_OA    = "Shared_Area"
),
# compute compliance
compliance = 1 - (extraction / 50),
complianceDummy = if_else(compliance == 1, 1, 0)  # vectorised if
)
with(df_long_ext, {
treat.area <- paste0(area, "_", treatment)
# Define factor with desired order
treat.area <- factor(treat.area,
levels = c(
"TURF_T1", "TURF_T2",
"Shared_Area_T1", "Shared_Area_T2"
))
# Explicitly relevel to ensure baseline
treat.area <- relevel(treat.area, ref = "TURF_T1")
df_long_ext$treat.area <<- treat.area
})
df_long_ext$area <- relevel(factor(df_long_ext$area), ref = "TURF")
### Empirical tests of H1 and H2: differences between SA in T1 and Turf in T1 and T2:
# Fit models (yours):
model  <- lmer(compliance ~ treat.area + (1 | participant.code), data = df_long_ext)
model2 <- lmer(compliance ~ area * treatment + (1 | participant.code), data = df_long_ext)
# One coef map covering ALL terms that appear in either model (order = row order)
coef_map <- c(
"(Intercept)"                      = "Intercept (TURF rounds 1–8)",
"treat.areaTURF_T2"                = "TURF (rounds 9–16)",
"treat.areaShared_Area_T1"         = "Shared Area Unknown Out-group",
"treat.areaShared_Area_T2"         = "Shared Area Known Out-group",
"areaShared_Area"                  = "Area (Shared)",
"treatmentT2"                      = "Stage (rounds 9-16)",
"areaShared_Area:treatmentT2"      = "Area × Stage"
)
# Model names for columns
models <- list(
"H1: TURF vs Shared Area"     = model,
"H2: Area × Stage"    = model2
)
df_long_ext <- dfs_long %>%
pivot_longer(
cols = c(extraction_amerb, extraction_OA),
names_to = "area",
values_to = "extraction"
) %>%
mutate(
# simplify area labels
area = recode(
area,
extraction_amerb = "TURF",
extraction_OA    = "Shared_Area"
),
# compute compliance
compliance = 1 - (extraction / 50),
complianceDummy = if_else(compliance == 1, 1, 0)  # vectorised if
)
with(df_long_ext, {
treat.area <- paste0(area, "_", treatment)
# Define factor with desired order
treat.area <- factor(treat.area,
levels = c(
"TURF_T1", "TURF_T2",
"Shared_Area_T1", "Shared_Area_T2"
))
# Explicitly relevel to ensure baseline
treat.area <- relevel(treat.area, ref = "TURF_T1")
df_long_ext$treat.area <<- treat.area
})
df_long_ext$area <- relevel(factor(df_long_ext$area), ref = "TURF")
model3  <- lmer(complianceDummy ~ treat.area + (1 | participant.code), data = df_long_ext)
model4 <- lmer(complianceDummy ~ area * treatment + (1 | participant.code), data = df_long_ext)
# One coef map covering ALL terms that appear in either model (order = row order)
coef_map <- c(
"(Intercept)"                      = "Intercept (TURF rounds 1–8)",
"treat.areaTURF_T2"                = "TURF (rounds 9–16)",
"treat.areaShared_Area_T1"         = "Shared Area Unknown Out-group",
"treat.areaShared_Area_T2"         = "Shared Area Known Out-group",
"areaShared_Area"                  = "Area (Shared)",
"treatmentT2"                      = "Stage (rounds 9-16)",
"areaShared_Area:treatmentT2"      = "Area × Stage"
)
# Model names for columns
models <- list(
"H1: TURF vs Shared Area"     = model3,
"H2: Area × Stage"    = model3
)
modelsummary(
models,
coef_map   = coef_map,
# optional: keep only the mapped rows (drop any stray contrasts)
coef_omit  = "^$",
stars      = c('*' = 0.05, '**' = 0.01, '***' = 0.001),
statistic  = "({std.error})",
gof_omit   = "IC|Log|RMSE",  # hide AIC/BIC/LogLik if you want a cleaner table
title      = "Empirical tests of H1 & H2 (LMM with random intercept by participant). Compliance defined as 0 or 1 (full compliance). ",
output     = paste0(path_github, "Outputs/LMM_H1_H2_SM.docx")
)
model3  <- lmer(complianceDummy ~ treat.area + (1 | participant.code), data = df_long_ext)
model4 <- lmer(complianceDummy ~ area * treatment + (1 | participant.code), data = df_long_ext)
# One coef map covering ALL terms that appear in either model (order = row order)
coef_map <- c(
"(Intercept)"                      = "Intercept (TURF rounds 1–8)",
"treat.areaTURF_T2"                = "TURF (rounds 9–16)",
"treat.areaShared_Area_T1"         = "Shared Area Unknown Out-group",
"treat.areaShared_Area_T2"         = "Shared Area Known Out-group",
"areaShared_Area"                  = "Area (Shared)",
"treatmentT2"                      = "Stage (rounds 9-16)",
"areaShared_Area:treatmentT2"      = "Area × Stage"
)
# Model names for columns
models <- list(
"H1: TURF vs Shared Area"     = model3,
"H2: Area × Stage"    = model4
)
modelsummary(
models,
coef_map   = coef_map,
# optional: keep only the mapped rows (drop any stray contrasts)
coef_omit  = "^$",
stars      = c('*' = 0.05, '**' = 0.01, '***' = 0.001),
statistic  = "({std.error})",
gof_omit   = "IC|Log|RMSE",  # hide AIC/BIC/LogLik if you want a cleaner table
title      = "Empirical tests of H1 & H2 (LMM with random intercept by participant). Compliance defined as 0 or 1 (full compliance). ",
output     = paste0(path_github, "Outputs/LMM_H1_H2_SM.docx")
)
model1 <- compliance_extraction_amerb ~ compliance_lag_extraction_others_amerb_mean +
compliance_beliefsT1inicial.1.player.T1_belief_caleta_en_amerb_ini +
treatment +
(1 | participant.code)
model2 <- compliance_extraction_amerb ~ compliance_lag_extraction_others_amerb_mean +
compliance_beliefsT1inicial.1.player.T1_belief_caleta_en_amerb_ini +
treatment  +
(survey1.1.player.confianza_caleta/4) + (survey1.1.player.conflicto_caleta/4)+
(1 | participant.code)
model3 <- compliance_extraction_amerb ~ compliance_lag_extraction_others_amerb_mean +
compliance_beliefsT1inicial.1.player.T1_belief_caleta_en_amerb_ini +
treatment +
(survey1.1.player.confianza_caleta/4) + (survey1.1.player.conflicto_caleta/4)+
survey3.1.player.sexo + survey3.1.player.horas_trabajo + survey3.1.player.estudios + survey3.1.player.liderazgo +
(1 | participant.code)
# Fit models on full dataset to get coefficient estimates
plm1 <-  lmer(formula_plm1, data = dfs_long)
# Define model formulas
model1 <- compliance_extraction_amerb ~ compliance_lag_extraction_others_amerb_mean +
compliance_beliefsT1inicial.1.player.T1_belief_caleta_en_amerb_ini +
treatment +
(1 | participant.code)
model2 <- compliance_extraction_amerb ~ compliance_lag_extraction_others_amerb_mean +
compliance_beliefsT1inicial.1.player.T1_belief_caleta_en_amerb_ini +
treatment  +
(survey1.1.player.confianza_caleta/4) + (survey1.1.player.conflicto_caleta/4)+
(1 | participant.code)
model3 <- compliance_extraction_amerb ~ compliance_lag_extraction_others_amerb_mean +
compliance_beliefsT1inicial.1.player.T1_belief_caleta_en_amerb_ini +
treatment +
(survey1.1.player.confianza_caleta/4) + (survey1.1.player.conflicto_caleta/4)+
survey3.1.player.sexo + survey3.1.player.horas_trabajo + survey3.1.player.estudios + survey3.1.player.liderazgo +
(1 | participant.code)
# Fit models on full dataset to get coefficient estimates
plm1 <-  lmer(mode1, data = dfs_long)
# Fit models on full dataset to get coefficient estimates
plm1 <-  lmer(model1, data = dfs_long)
plm2 <-  lmer(model2, data = dfs_long)
plm1 <-  lmer(model1 +
(1 | participant.code), data = dfs_long)
# Precompute scaled/renamed covariates (avoid var/4 inside formulas!)
dfs_long <- dfs_long %>%
mutate(
confianza_caleta_scaled = `survey1.1.player.confianza_caleta`/4,
conflicto_caleta_scaled = `survey1.1.player.conflicto_caleta`/4
)
model1 <- compliance_extraction_amerb ~
compliance_lag_extraction_others_amerb_mean +
compliance_beliefsT1inicial.1.player.T1_belief_caleta_en_amerb_ini +
treatment +
(1 | participant.code)
model2 <- compliance_extraction_amerb ~
compliance_lag_extraction_others_amerb_mean +
compliance_beliefsT1inicial.1.player.T1_belief_caleta_en_amerb_ini +
treatment +
confianza_caleta_scaled + conflicto_caleta_scaled +
(1 | participant.code)
model3 <- compliance_extraction_amerb ~
compliance_lag_extraction_others_amerb_mean +
compliance_beliefsT1inicial.1.player.T1_belief_caleta_en_amerb_ini +
treatment +
confianza_caleta_scaled + conflicto_caleta_scaled +
`survey3.1.player.sexo` + `survey3.1.player.horas_trabajo` +
`survey3.1.player.estudios` + `survey3.1.player.liderazgo` +
(1 | participant.code)
# -----------------------------
# Fit full-sample models (for point estimates + coef names)
# -----------------------------
ctrl <- lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5))
plm1 <- lmer(model1, data = dfs_long, control = ctrl, REML = FALSE)
plm2 <- lmer(model2, data = dfs_long, control = ctrl, REML = FALSE)
plm3 <- lmer(model3, data = dfs_long, control = ctrl, REML = FALSE)
ctrl <- lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5))
plm1 <- lmer(model1, data = dfs_long, control = ctrl, REML = FALSE)
plm2 <- lmer(model2, data = dfs_long, control = ctrl, REML = FALSE)
plm3 <- lmer(model3, data = dfs_long, control = ctrl, REML = FALSE)
coef_names1 <- names(fixef(plm1))
coef_names2 <- names(fixef(plm2))
coef_names3 <- names(fixef(plm3))
#
bootstrap_model <- function(data, indices, model_formula, cluster_var, coef_names) {
# Identify unique clusters and sample with replacement
clusters <- unique(data[[cluster_var]])
sampled <- sample(clusters, length(clusters), replace = TRUE)
# Bind rows for each sampled cluster (to preserve multiplicity)
data_sample <- dplyr::bind_rows(lapply(sampled, function(cl) data[data[[cluster_var]] == cl, , drop = FALSE]))
# Refit the model; catch failures and return NAs aligned to coef_names
fit <- try(lmer(model_formula, data = data_sample, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 5e4)), REML = FALSE), silent = TRUE)
out <- rep(NA_real_, length(coef_names))
names(out) <- coef_names
if (inherits(fit, "try-error")) return(out)
cf <- try(fixef(fit), silent = TRUE)
if (inherits(cf, "try-error")) return(out)
out[names(cf)] <- cf
return(out)
}
# -----------------------------
# Run bootstrap (B replications)
# -----------------------------
set.seed(62354)
B <- 100  # increase to 500–1000 for final SM
boot1 <- boot(data = dfs_long, statistic = bootstrap_model, R = B,
model_formula = model1, cluster_var = "gid.amerb", coef_names = coef_names1)
# Define a function to resample clusters and fit a plm model
bootstrap_model <- function(data, indices, model_formula, cluster_var) {
# Get unique clusters
unique_clusters <- unique(data[[cluster_var]])
# Sample clusters (with replacement)
sampled_clusters <- sample(unique_clusters, length(unique_clusters), replace = TRUE)
# Subset data based on sampled clusters
data_sample <- data[data[[cluster_var]] %in% sampled_clusters, ]
# Fit the model
model <- plm(model_formula, data = data_sample, model = "random")
# Return coefficients
return(coef(model))
}
# Number of bootstrap replications
B <- 100
set.seed(62354)
set.seed(62354)
B <- 100  # increase to 500–1000 for final SM
boot1 <- bootstrap_model (data = dfs_long, statistic = bootstrap_model, R = B,
model_formula = model1, cluster_var = "gid.amerb", coef_names = coef_names1)
# Load required packages
library(plm)
library(boot)
library(stargazer)
library(dplyr)
library(tidyr)
library(lme4)
rm(list=ls())
path_github <-"C:/Users/DCCS2/Documents/GitHub/Multi-level-collective-action-in-small-scale-fisheries/Exptal Sessions/R/"
path_datos<-"C:/Users/DCCS2/Dropbox/CICS/Experiments/Islitas/Data/Sessions"
#path_github <-"C:/Users/Denise Laroze/Documents/GitHub/Multi-level-collective-action-in-small-scale-fisheries/Exptal Sessions/R/"
#path_datos<-"C:/Users/Denise Laroze/Dropbox/CICS/Experiments/Islitas/Data/Sessions"
setwd(path_github)
#load(paste0(path_datos, "/Datos_islitas.Rdata"))
load(paste0(path_datos, "/Datos_islitas_recode.Rdata"))
load(paste0(path_datos, "/Datos_islitas_long.Rdata"))
# Precompute scaled/renamed covariates (avoid var/4 inside formulas!)
dfs_long <- dfs_long %>%
mutate(
confianza_caleta_scaled = survey1.1.player.confianza_caleta/4,
conflicto_caleta_scaled = survey1.1.player.conflicto_caleta/4
)
model1 <- compliance_extraction_amerb ~
compliance_lag_extraction_others_amerb_mean +
compliance_beliefsT1inicial.1.player.T1_belief_caleta_en_amerb_ini +
treatment +
(1 | participant.code)
model2 <- compliance_extraction_amerb ~
compliance_lag_extraction_others_amerb_mean +
compliance_beliefsT1inicial.1.player.T1_belief_caleta_en_amerb_ini +
treatment +
confianza_caleta_scaled + conflicto_caleta_scaled +
(1 | participant.code)
model3 <- compliance_extraction_amerb ~
compliance_lag_extraction_others_amerb_mean +
compliance_beliefsT1inicial.1.player.T1_belief_caleta_en_amerb_ini +
treatment +
confianza_caleta_scaled + conflicto_caleta_scaled +
survey3.1.player.sexo + survey3.1.player.horas_trabajo +
`survey3.1.player.estudios + survey3.1.player.liderazgo +
(1 | participant.code)
ctrl <- lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5))
plm1 <- lmer(model1, data = dfs_long, control = ctrl, REML = FALSE)
plm2 <- lmer(model2, data = dfs_long, control = ctrl, REML = FALSE)
plm3 <- lmer(model3, data = dfs_long, control = ctrl, REML = FALSE)
coef_names1 <- names(fixef(plm1))
coef_names2 <- names(fixef(plm2))
coef_names3 <- names(fixef(plm3))
bootstrap_model <- function(data, indices, model_formula, cluster_var, coef_names) {
# Identify unique clusters and sample with replacement
clusters <- unique(data[[cluster_var]])
sampled <- sample(clusters, length(clusters), replace = TRUE)
# Bind rows for each sampled cluster (to preserve multiplicity)
data_sample <- dplyr::bind_rows(lapply(sampled, function(cl) data[data[[cluster_var]] == cl, , drop = FALSE]))
# Refit the model; catch failures and return NAs aligned to coef_names
fit <- try(lmer(model_formula, data = data_sample, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 5e4)), REML = FALSE), silent = TRUE)
out <- rep(NA_real_, length(coef_names))
names(out) <- coef_names
if (inherits(fit, "try-error")) return(out)
cf <- try(fixef(fit), silent = TRUE)
if (inherits(cf, "try-error")) return(out)
out[names(cf)] <- cf
return(out)
}
library(plm)
library(boot)
library(stargazer)
library(dplyr)
library(tidyr)
library(lme4)
rm(list=ls())
path_github <-"C:/Users/DCCS2/Documents/GitHub/Multi-level-collective-action-in-small-scale-fisheries/Exptal Sessions/R/"
path_datos<-"C:/Users/DCCS2/Dropbox/CICS/Experiments/Islitas/Data/Sessions"
#path_github <-"C:/Users/Denise Laroze/Documents/GitHub/Multi-level-collective-action-in-small-scale-fisheries/Exptal Sessions/R/"
#path_datos<-"C:/Users/Denise Laroze/Dropbox/CICS/Experiments/Islitas/Data/Sessions"
setwd(path_github)
#load(paste0(path_datos, "/Datos_islitas.Rdata"))
load(paste0(path_datos, "/Datos_islitas_recode.Rdata"))
load(paste0(path_datos, "/Datos_islitas_long.Rdata"))
# Precompute scaled/renamed covariates (avoid var/4 inside formulas!)
dfs_long <- dfs_long %>%
mutate(
confianza_caleta_scaled = survey1.1.player.confianza_caleta/4,
conflicto_caleta_scaled = survey1.1.player.conflicto_caleta/4
)
# -----------------------------
# Model formulas (include random intercept)
# -----------------------------
model1 <- compliance_extraction_amerb ~
compliance_lag_extraction_others_amerb_mean +
compliance_beliefsT1inicial.1.player.T1_belief_caleta_en_amerb_ini +
treatment +
(1 | participant.code)
model2 <- compliance_extraction_amerb ~
compliance_lag_extraction_others_amerb_mean +
compliance_beliefsT1inicial.1.player.T1_belief_caleta_en_amerb_ini +
treatment +
confianza_caleta_scaled + conflicto_caleta_scaled +
(1 | participant.code)
model3 <- compliance_extraction_amerb ~
compliance_lag_extraction_others_amerb_mean +
compliance_beliefsT1inicial.1.player.T1_belief_caleta_en_amerb_ini +
treatment +
confianza_caleta_scaled + conflicto_caleta_scaled +
survey3.1.player.sexo + survey3.1.player.horas_trabajo +
`survey3.1.player.estudios + survey3.1.player.liderazgo +
library(plm)
library(boot)
library(stargazer)
library(dplyr)
library(tidyr)
library(lme4)
rm(list=ls())
path_github <-"C:/Users/DCCS2/Documents/GitHub/Multi-level-collective-action-in-small-scale-fisheries/Exptal Sessions/R/"
path_datos<-"C:/Users/DCCS2/Dropbox/CICS/Experiments/Islitas/Data/Sessions"
#path_github <-"C:/Users/Denise Laroze/Documents/GitHub/Multi-level-collective-action-in-small-scale-fisheries/Exptal Sessions/R/"
#path_datos<-"C:/Users/Denise Laroze/Dropbox/CICS/Experiments/Islitas/Data/Sessions"
setwd(path_github)
#load(paste0(path_datos, "/Datos_islitas.Rdata"))
load(paste0(path_datos, "/Datos_islitas_recode.Rdata"))
load(paste0(path_datos, "/Datos_islitas_long.Rdata"))
# Precompute scaled/renamed covariates (avoid var/4 inside formulas!)
dfs_long <- dfs_long %>%
mutate(
confianza_caleta_scaled = survey1.1.player.confianza_caleta/4,
conflicto_caleta_scaled = survey1.1.player.conflicto_caleta/4
)
# -----------------------------
# Model formulas (include random intercept)
# -----------------------------
model1 <- compliance_extraction_amerb ~
compliance_lag_extraction_others_amerb_mean +
compliance_beliefsT1inicial.1.player.T1_belief_caleta_en_amerb_ini +
treatment +
(1 | participant.code)
model2 <- compliance_extraction_amerb ~
compliance_lag_extraction_others_amerb_mean +
compliance_beliefsT1inicial.1.player.T1_belief_caleta_en_amerb_ini +
treatment +
confianza_caleta_scaled + conflicto_caleta_scaled +
(1 | participant.code)
model3 <- compliance_extraction_amerb ~
compliance_lag_extraction_others_amerb_mean +
compliance_beliefsT1inicial.1.player.T1_belief_caleta_en_amerb_ini +
treatment +
confianza_caleta_scaled + conflicto_caleta_scaled +
survey3.1.player.sexo + survey3.1.player.horas_trabajo +
survey3.1.player.estudios + survey3.1.player.liderazgo +
(1 | participant.code)
# -----------------------------
# Fit full-sample models (for point estimates + coef names)
# -----------------------------
ctrl <- lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5))
plm1 <- lmer(model1, data = dfs_long, control = ctrl, REML = FALSE)
plm2 <- lmer(model2, data = dfs_long, control = ctrl, REML = FALSE)
plm3 <- lmer(model3, data = dfs_long, control = ctrl, REML = FALSE)
coef_names1 <- names(fixef(plm1))
coef_names2 <- names(fixef(plm2))
coef_names3 <- names(fixef(plm3))
# -----------------------------
# Clustered bootstrap function
# -----------------------------
bootstrap_model <- function(data, indices, model_formula, cluster_var, coef_names) {
# Identify unique clusters and sample with replacement
clusters <- unique(data[[cluster_var]])
sampled <- sample(clusters, length(clusters), replace = TRUE)
# Bind rows for each sampled cluster (to preserve multiplicity)
data_sample <- dplyr::bind_rows(lapply(sampled, function(cl) data[data[[cluster_var]] == cl, , drop = FALSE]))
# Refit the model; catch failures and return NAs aligned to coef_names
fit <- try(lmer(model_formula, data = data_sample, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 5e4)), REML = FALSE), silent = TRUE)
out <- rep(NA_real_, length(coef_names))
names(out) <- coef_names
if (inherits(fit, "try-error")) return(out)
cf <- try(fixef(fit), silent = TRUE)
if (inherits(cf, "try-error")) return(out)
out[names(cf)] <- cf
return(out)
}
# -----------------------------
# Run bootstrap (B replications)
# -----------------------------
set.seed(62354)
B <- 100  # increase to 500–1000 for final SM
boot1 <- bootstrap_model (data = dfs_long, statistic = bootstrap_model, R = B,
model_formula = model1, cluster_var = "gid.amerb", coef_names = coef_names1)
install.packages("boot")
