identity_map <- function(id) {
degree <- sub("\\.\\d+$", "", id)
return(degree)
}
# Individual experience type
individual_experience <- function(self, group, proximity_matrix) {
self_identity <- identity_map(self)
others <- setdiff(group, self)
other_identities <- sapply(others, identity_map)
if (!(self_identity %in% rownames(proximity_matrix)) || any(!other_identities %in% colnames(proximity_matrix))) {
return("hetero_mix")
}
proximity_scores <- proximity_matrix[self_identity, other_identities]
if (all(proximity_scores == "self")) {
return("homogeneous")
} else if (all(proximity_scores %in% c("self", "near"))) {
return("near_mix")
} else if (all(proximity_scores %in% c("self", "far"))) {
return("far_mix")
} else {
return("hetero_mix")
}
}
# Proximity score function
proximity_score <- function(group, proximity_matrix) {
identities <- sapply(group, identity_map)
unique_ids <- unique(identities)
if (length(unique_ids) == 1) {
return("homogeneous")
}
if (any(!unique_ids %in% rownames(proximity_matrix))) return("hetero_mix")
proximity_scores <- proximity_matrix[unique_ids, unique_ids]
if (all(proximity_scores %in% c("self", "near"))) {
return("near_mix")
} else if (all(proximity_scores %in% c("self", "far"))) {
return("far_mix")
} else {
return("hetero_mix")
}
}
# Group generator with at least one homogeneous group
generate_groups_with_individuals <- function(participants, proximity_matrix) {
repeat {
shuffled <- sample(participants)
n <- length(shuffled)
group_count <- floor(n / 3)
groups <- split(shuffled[1:(group_count * 3)], rep(1:group_count, each=3))
results <- list()
has_homogeneous <- FALSE
for (i in seq_along(groups)) {
g <- groups[[i]]
ids <- sapply(g, identity_map)
group_type <- proximity_score(g, proximity_matrix)
if (group_type == "homogeneous") {
has_homogeneous <- TRUE
}
group_result <- list(
members = g,
identities = ids,
group_type = group_type,
individual_experience = setNames(
sapply(g, function(self) individual_experience(self, g, proximity_matrix)),
g
)
)
results[[i]] <- group_result
}
if (has_homogeneous) return(results)
}
}
# Sampling simulation structure to analyze balance
sample_balanced_session <- function(n_total = 15) {
degrees <- names(proximity_matrix)
selected <- sample(degrees, sample(2:4, 1))  # random 2 to 4 degrees
dominant <- sample(selected, 1)
dominant_pool <- paste0(dominant, ".", 1:20)
dominant_n <- sample(3:min(6, length(dominant_pool)), 1)
remaining_n <- n_total - dominant_n
rest_degrees <- setdiff(selected, dominant)
rest_alloc <- if (length(rest_degrees) > 0) rmultinom(1, remaining_n, rep(1, length(rest_degrees))) else NULL
counts <- setNames(c(dominant_n, as.vector(rest_alloc)), c(dominant, rest_degrees))
all_samples <- unlist(mapply(function(deg, n) {
ids <- paste0(deg, ".", 1:20)
sample(ids, min(n, length(ids)))
}, names(counts), counts))
return(all_samples)
}
# Run 12 sessions with sampling structure
set.seed(1)
total_experiences <- c()
session_compositions <- list()
for (i in 1:12) {
p1 <- sample_balanced_session(n_total = 15)
session_compositions[[paste0("Session_", i)]] <- table(sapply(p1, identity_map))
groups <- generate_groups_with_individuals(p1, proximity_matrix)
for (group in groups) {
total_experiences <- c(total_experiences, group$individual_experience)
}
}
# Define degrees grouped by macro-faculty (Spanish names)
macro_faculties <- list(
"Ciencias de la Salud y Medicina" = c("Medicina", "Enfermería", "Kinesiología", "Tecnología Médica", "Nutrición y Dietética", "Odontología", "Obstetricia", "Terapia Ocupacional", "Química y Farmacia", "Fonoaudiología"),
"Ingeniería y Ciencias Aplicadas" = c("Ingeniería Civil Plan Común", "Ingeniería Civil Industrial", "Ingeniería Civil en Informática e Innovación Tecnológica", "Ingeniería Civil en Informática e Inteligencia Artificial", "Ingeniería Civil en Minería", "Ingeniería Civil en Obras Civiles", "Ingeniería Civil en BioMedicina", "Geología", "Data Business Intelligence"),
"Artes, Diseño y Comunicación" = c("Arquitectura", "Diseño", "Cine", "Publicidad", "Periodismo y Comunicación", "Bachillerato en Diseño"),
"Ciencias Sociales, Derecho, Negocios y Educación" = c("Derecho", "Ingeniería Comercial", "Global Business Administration", "Bachillerato en Ingeniería Comercial", "Ciencia Política y Políticas Públicas", "Pedagogía en Educación Básica", "Pedagogía en Educación de Párvulos", "Programa de Formación Pedagógica", "Psicología", "Bachillerato en Psicología")
)
# Proximity matrix construction from macro_faculties
degree_list <- unlist(macro_faculties)
names(degree_list) <- NULL
all_degree_pairs <- expand.grid(from = degree_list, to = degree_list, stringsAsFactors = FALSE)
all_degree_pairs$proximity <- apply(all_degree_pairs, 1, function(row) {
same_macro <- any(sapply(macro_faculties, function(degs) row["from"] %in% degs && row["to"] %in% degs))
if (row["from"] == row["to"]) "self" else if (same_macro) "near" else "far"
})
proximity_matrix <- reshape2::acast(all_degree_pairs, from ~ to, value.var = "proximity")
# Identity mapping using degree from ID
identity_map <- function(id) {
degree <- sub("\\.\\d+$", "", id)
return(degree)
}
# Individual experience type
individual_experience <- function(self, group, proximity_matrix) {
self_identity <- identity_map(self)
others <- setdiff(group, self)
other_identities <- sapply(others, identity_map)
if (!(self_identity %in% rownames(proximity_matrix)) || any(!other_identities %in% colnames(proximity_matrix))) {
return("hetero_mix")
}
proximity_scores <- proximity_matrix[self_identity, other_identities]
if (all(proximity_scores == "self")) {
return("homogeneous")
} else if (all(proximity_scores %in% c("self", "near"))) {
return("near_mix")
} else if (all(proximity_scores %in% c("self", "far"))) {
return("far_mix")
} else {
return("hetero_mix")
}
}
# Proximity score function
proximity_score <- function(group, proximity_matrix) {
identities <- sapply(group, identity_map)
unique_ids <- unique(identities)
if (length(unique_ids) == 1) {
return("homogeneous")
}
if (any(!unique_ids %in% rownames(proximity_matrix))) return("hetero_mix")
proximity_scores <- proximity_matrix[unique_ids, unique_ids]
if (all(proximity_scores %in% c("self", "near"))) {
return("near_mix")
} else if (all(proximity_scores %in% c("self", "far"))) {
return("far_mix")
} else {
return("hetero_mix")
}
}
# Group generator with at least one homogeneous group
generate_groups_with_individuals <- function(participants, proximity_matrix) {
repeat {
shuffled <- sample(participants)
n <- length(shuffled)
group_count <- floor(n / 3)
groups <- split(shuffled[1:(group_count * 3)], rep(1:group_count, each=3))
results <- list()
has_homogeneous <- FALSE
for (i in seq_along(groups)) {
g <- groups[[i]]
ids <- sapply(g, identity_map)
group_type <- proximity_score(g, proximity_matrix)
if (group_type == "homogeneous") {
has_homogeneous <- TRUE
}
group_result <- list(
members = g,
identities = ids,
group_type = group_type,
individual_experience = setNames(
sapply(g, function(self) individual_experience(self, g, proximity_matrix)),
g
)
)
results[[i]] <- group_result
}
if (has_homogeneous) return(results)
}
}
# Sampling simulation structure to analyze balance
sample_balanced_session <- function(n_total = 15) {
degrees <- names(proximity_matrix)
selected <- sample(degrees, sample(2:4, 1))  # random 2 to 4 degrees
dominant <- sample(selected, 1)
dominant_pool <- paste0(dominant, ".", 1:20)
dominant_n <- sample(3:min(6, length(dominant_pool)), 1)
remaining_n <- n_total - dominant_n
rest_degrees <- setdiff(selected, dominant)
rest_alloc <- if (length(rest_degrees) > 0) rmultinom(1, remaining_n, rep(1, length(rest_degrees))) else NULL
counts <- setNames(c(dominant_n, as.vector(rest_alloc)), c(dominant, rest_degrees))
all_samples <- unlist(mapply(function(deg, n) {
ids <- paste0(deg, ".", 1:20)
sample(ids, min(n, length(ids)))
}, names(counts), counts))
return(all_samples)
}
# Run 12 sessions with sampling structure
set.seed(1)
total_experiences <- c()
session_compositions <- list()
for (i in 1:12) {
p1 <- sample_balanced_session(n_total = 15)
session_compositions[[paste0("Session_", i)]] <- table(sapply(p1, identity_map))
groups <- generate_groups_with_individuals(p1, proximity_matrix)
for (group in groups) {
total_experiences <- c(total_experiences, group$individual_experience)
}
}
# Define degrees grouped by macro-faculty (Spanish names)
macro_faculties <- list(
"Ciencias de la Salud y Medicina" = c("Medicina", "Enfermería", "Kinesiología", "Tecnología Médica", "Nutrición y Dietética", "Odontología", "Obstetricia", "Terapia Ocupacional", "Química y Farmacia", "Fonoaudiología"),
"Ingeniería y Ciencias Aplicadas" = c("Ingeniería Civil Plan Común", "Ingeniería Civil Industrial", "Ingeniería Civil en Informática e Innovación Tecnológica", "Ingeniería Civil en Informática e Inteligencia Artificial", "Ingeniería Civil en Minería", "Ingeniería Civil en Obras Civiles", "Ingeniería Civil en BioMedicina", "Geología", "Data Business Intelligence"),
"Artes, Diseño y Comunicación" = c("Arquitectura", "Diseño", "Cine", "Publicidad", "Periodismo y Comunicación", "Bachillerato en Diseño"),
"Ciencias Sociales, Derecho, Negocios y Educación" = c("Derecho", "Ingeniería Comercial", "Global Business Administration", "Bachillerato en Ingeniería Comercial", "Ciencia Política y Políticas Públicas", "Pedagogía en Educación Básica", "Pedagogía en Educación de Párvulos", "Programa de Formación Pedagógica", "Psicología", "Bachillerato en Psicología")
)
# Proximity matrix construction from macro_faculties
degree_list <- unlist(macro_faculties)
names(degree_list) <- NULL
all_degree_pairs <- expand.grid(from = degree_list, to = degree_list, stringsAsFactors = FALSE)
all_degree_pairs$proximity <- apply(all_degree_pairs, 1, function(row) {
same_macro <- any(sapply(macro_faculties, function(degs) row["from"] %in% degs && row["to"] %in% degs))
if (row["from"] == row["to"]) "self" else if (same_macro) "near" else "far"
})
proximity_matrix <- reshape2::acast(all_degree_pairs, from ~ to, value.var = "proximity")
# Identity mapping using degree from ID
identity_map <- function(id) {
degree <- sub("\\.\\d+$", "", id)
return(degree)
}
# Individual experience type
individual_experience <- function(self, group, proximity_matrix) {
self_identity <- identity_map(self)
others <- setdiff(group, self)
other_identities <- sapply(others, identity_map)
if (!(self_identity %in% rownames(proximity_matrix)) || any(!other_identities %in% colnames(proximity_matrix))) {
return("hetero_mix")
}
proximity_scores <- proximity_matrix[self_identity, other_identities]
if (all(proximity_scores == "self")) {
return("homogeneous")
} else if (all(proximity_scores %in% c("self", "near"))) {
return("near_mix")
} else if (all(proximity_scores %in% c("self", "far"))) {
return("far_mix")
} else {
return("hetero_mix")
}
}
# Proximity score function
proximity_score <- function(group, proximity_matrix) {
identities <- sapply(group, identity_map)
unique_ids <- unique(identities)
if (length(unique_ids) == 1) {
return("homogeneous")
}
if (any(!unique_ids %in% rownames(proximity_matrix))) return("hetero_mix")
proximity_scores <- proximity_matrix[unique_ids, unique_ids]
if (all(proximity_scores %in% c("self", "near"))) {
return("near_mix")
} else if (all(proximity_scores %in% c("self", "far"))) {
return("far_mix")
} else {
return("hetero_mix")
}
}
# Group generator with at least one homogeneous group
generate_groups_with_individuals <- function(participants, proximity_matrix) {
repeat {
shuffled <- sample(participants)
n <- length(shuffled)
group_count <- floor(n / 3)
groups <- split(shuffled[1:(group_count * 3)], rep(1:group_count, each=3))
results <- list()
has_homogeneous <- FALSE
for (i in seq_along(groups)) {
g <- groups[[i]]
ids <- sapply(g, identity_map)
group_type <- proximity_score(g, proximity_matrix)
if (group_type == "homogeneous") {
has_homogeneous <- TRUE
}
group_result <- list(
members = g,
identities = ids,
group_type = group_type,
individual_experience = setNames(
sapply(g, function(self) individual_experience(self, g, proximity_matrix)),
g
)
)
results[[i]] <- group_result
}
if (has_homogeneous) return(results)
}
}
# Sampling simulation structure to analyze balance
sample_balanced_session <- function(n_total = 15) {
degrees <- names(proximity_matrix)
selected <- sample(degrees, sample(2:4, 1))  # random 2 to 4 degrees
dominant <- sample(selected, 1)
dominant_pool <- paste0(dominant, ".", 1:20)
max_dominant <- min(6, length(dominant_pool))
if (max_dominant < 3) return(NULL) # skip if not enough "students"
dominant_n <- sample(3:max_dominant, 1)
remaining_n <- n_total - dominant_n
rest_degrees <- setdiff(selected, dominant)
rest_alloc <- if (length(rest_degrees) > 0 && remaining_n > 0) rmultinom(1, remaining_n, rep(1, length(rest_degrees))) else NULL
counts <- setNames(c(dominant_n, as.vector(rest_alloc)), c(dominant, rest_degrees))
all_samples <- unlist(mapply(function(deg, n) {
ids <- paste0(deg, ".", 1:20)
n_ids <- min(n, length(ids))
if (n_ids < 1) return(character(0))
sample(ids, n_ids)
}, names(counts), counts))
if (length(all_samples) < n_total) return(NULL)  # skip if underfilled
return(all_samples)
}
# Run 12 sessions with robust sampling structure
set.seed(1)
total_experiences <- c()
session_compositions <- list()
n_sessions <- 12
n_completed <- 0
while (n_completed < n_sessions) {
p1 <- sample_balanced_session(n_total = 15)
if (is.null(p1)) next
n_completed <- n_completed + 1
session_compositions[[paste0("Session_", n_completed)]] <- table(sapply(p1, identity_map))
groups <- generate_groups_with_individuals(p1, proximity_matrix)
for (group in groups) {
total_experiences <- c(total_experiences, group$individual_experience)
}
}
macro_faculties <- list(
"Ciencias de la Salud y Medicina" = c("Medicina", "Enfermería", "Kinesiología", "Tecnología Médica", "Nutrición y Dietética", "Odontología", "Obstetricia", "Terapia Ocupacional", "Química y Farmacia", "Fonoaudiología"),
"Ingeniería y Ciencias Aplicadas" = c("Ingeniería Civil Plan Común", "Ingeniería Civil Industrial", "Ingeniería Civil en Informática e Innovación Tecnológica", "Ingeniería Civil en Informática e Inteligencia Artificial", "Ingeniería Civil en Minería", "Ingeniería Civil en Obras Civiles", "Ingeniería Civil en BioMedicina", "Geología", "Data Business Intelligence"),
"Artes, Diseño y Comunicación" = c("Arquitectura", "Diseño", "Cine", "Publicidad", "Periodismo y Comunicación", "Bachillerato en Diseño"),
"Ciencias Sociales, Derecho, Negocios y Educación" = c("Derecho", "Ingeniería Comercial", "Global Business Administration", "Bachillerato en Ingeniería Comercial", "Ciencia Política y Políticas Públicas", "Pedagogía en Educación Básica", "Pedagogía en Educación de Párvulos", "Programa de Formación Pedagógica", "Psicología", "Bachillerato en Psicología")
)
# Proximity matrix construction from macro_faculties
degree_list <- unlist(macro_faculties)
names(degree_list) <- NULL
all_degree_pairs <- expand.grid(from = degree_list, to = degree_list, stringsAsFactors = FALSE)
all_degree_pairs$proximity <- apply(all_degree_pairs, 1, function(row) {
same_macro <- any(sapply(macro_faculties, function(degs) row["from"] %in% degs && row["to"] %in% degs))
if (row["from"] == row["to"]) "self" else if (same_macro) "near" else "far"
})
proximity_matrix <- reshape2::acast(all_degree_pairs, from ~ to, value.var = "proximity")
# Identity mapping using degree from ID
identity_map <- function(id) {
degree <- sub("\\.\\d+$", "", id)
return(degree)
}
# Individual experience type
individual_experience <- function(self, group, proximity_matrix) {
self_identity <- identity_map(self)
others <- setdiff(group, self)
other_identities <- sapply(others, identity_map)
if (!(self_identity %in% rownames(proximity_matrix)) || any(!other_identities %in% colnames(proximity_matrix))) {
return("hetero_mix")
}
proximity_scores <- proximity_matrix[self_identity, other_identities]
if (all(proximity_scores == "self")) {
return("homogeneous")
} else if (all(proximity_scores %in% c("self", "near"))) {
return("near_mix")
} else if (all(proximity_scores %in% c("self", "far"))) {
return("far_mix")
} else {
return("hetero_mix")
}
}
# Proximity score function
proximity_score <- function(group, proximity_matrix) {
identities <- sapply(group, identity_map)
unique_ids <- unique(identities)
if (length(unique_ids) == 1) {
return("homogeneous")
}
if (any(!unique_ids %in% rownames(proximity_matrix))) return("hetero_mix")
proximity_scores <- proximity_matrix[unique_ids, unique_ids]
if (all(proximity_scores %in% c("self", "near"))) {
return("near_mix")
} else if (all(proximity_scores %in% c("self", "far"))) {
return("far_mix")
} else {
return("hetero_mix")
}
}
# Group generator with at least one homogeneous group
generate_groups_with_individuals <- function(participants, proximity_matrix) {
repeat {
shuffled <- sample(participants)
n <- length(shuffled)
group_count <- floor(n / 3)
groups <- split(shuffled[1:(group_count * 3)], rep(1:group_count, each=3))
results <- list()
has_homogeneous <- FALSE
for (i in seq_along(groups)) {
g <- groups[[i]]
ids <- sapply(g, identity_map)
group_type <- proximity_score(g, proximity_matrix)
if (group_type == "homogeneous") {
has_homogeneous <- TRUE
}
group_result <- list(
members = g,
identities = ids,
group_type = group_type,
individual_experience = setNames(
sapply(g, function(self) individual_experience(self, g, proximity_matrix)),
g
)
)
results[[i]] <- group_result
}
if (has_homogeneous) return(results)
}
}
# Load necessary libraries
library(dplyr)
library(tidyr)
library(ggplot2)
library(stargazer)
library(sandwich)   # For robust and clustered standard errors
library(lmtest)
library(lme4)
library(modelsummary)
prop.table(table(df$survey3.1.player.sexo))
prop.table(table(df$survey3.1.player.liderazgo))
prop.table(table(df$survey3.1.player.experiencia))
prop.table(table(df$survey3.1.player.estudios))
age<-2024-df$survey3.1.player.nacimiento
summary(age)
sd(age)
summary(df$survey3.1.player.horas_trabajo)
sd(df$survey3.1.player.horas_trabajo)
rm(list=ls())
#path_github <-"C:/Users/DCCS2/Documents/GitHub/Multi-level-collective-action-in-small-scale-fisheries/Exptal Sessions/R/"
#path_datos<-"C:/Users/DCCS2/Dropbox/CICS/Experiments/Islitas/Data/Sessions"
path_github <-"C:/Users/Denise Laroze/Documents/GitHub/Multi-level-collective-action-in-small-scale-fisheries/Exptal Sessions/R/"
path_datos<-"C:/Users/Denise Laroze/Dropbox/CICS/Experiments/Islitas/Data/Sessions"
setwd(path_github)
#load(paste0(path_datos, "/Datos_islitas.Rdata"))
load(paste0(path_datos, "/Datos_islitas_recode.Rdata"))
load(paste0(path_datos, "/Datos_islitas_long.Rdata"))
df_long_ext <- dfs_long %>%
pivot_longer(
cols = c(extraction_amerb, extraction_OA),
names_to = "area",
values_to = "extraction"
) %>%
mutate(
# simplify area labels
area = recode(
area,
extraction_amerb = "TURF",
extraction_OA    = "Shared_Area"
),
# compute compliance
compliance = 1 - (extraction / 50)
)
with(df_long_ext, {
treat.area <- paste0(area, "_", treatment)
# Define factor with desired order
treat.area <- factor(treat.area,
levels = c(
"TURF_T1", "TURF_T2",
"Shared_Area_T1", "Shared_Area_T2"
))
# Explicitly relevel to ensure baseline
treat.area <- relevel(treat.area, ref = "TURF_T1")
df_long_ext$treat.area <<- treat.area
})
df_long_ext$area <- relevel(factor(df_long_ext$area), ref = "TURF")
### Empirical tests of H1 and H2: differences between SA in T1 and Turf in T1 and T2:
# Fit models (yours):
model  <- lmer(compliance ~ treat.area + (1 | participant.code), data = df_long_ext)
model2 <- lmer(compliance ~ area * treatment + (1 | participant.code), data = df_long_ext)
# One coef map covering ALL terms that appear in either model (order = row order)
coef_map <- c(
"(Intercept)"                      = "Intercept (TURF rounds 1–8)",
"treat.areaTURF_T2"                = "TURF rounds 9–16 (dummy)",
"treat.areaShared_Area_T1"         = "Shared Area Unknown Out-group (dummy)",
"treat.areaShared_Area_T2"         = "Shared Area Known Out-group (dummy)",
"areaShared_Area"                  = "Shared Area (dummy)",
"treatmentT2"                      = "Known Out-group condition (dummy)",
"areaShared_Area:treatmentT2"      = "Area × Known Out-group"
)
# Model names for columns
models <- list(
"H1: TURF vs Shared Area"     = model,
"H2: Area × Known Out-group condition"    = model2
)
df_long_ext$complianceDummy<-ifelse(df_long_ext$compliance == 1,  1, 0)
df_long_ext$complianceDummy<-ifelse(df_long_ext$compliance == 1,  1, 0)
model3  <- lmer(complianceDummy ~ treat.area + (1 | participant.code), data = df_long_ext)
model4 <- lmer(complianceDummy ~ area * treatment + (1 | participant.code), data = df_long_ext)
summary(model3)
summary(model4)
table(df_long_ext$complianceDummy)
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
