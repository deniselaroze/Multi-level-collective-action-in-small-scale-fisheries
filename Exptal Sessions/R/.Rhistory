beta1 <- c(intercept = -1, X1 =  0.8, X2 =  0.5)
beta2 <- c(intercept =  0, X1 =  1.2, X2 = -0.3)
# 3. Calcular utilidades y probabilidades
# matriz de diseño
X <- cbind(1, X1, X2)
# utilidades lineales
eta1 <- X %*% beta1
eta2 <- X %*% beta2
# probabilidades multinomiales con base categoría 0
exp1 <- exp(eta1)
exp2 <- exp(eta2)
denom <- 1 + exp1 + exp2
p0 <- 1 / denom
p1 <- exp1 / denom
p2 <- exp2 / denom
# 4. Simular la categoría observada
U <- runif(n)
y_mul <- ifelse(U < p0, 0, ifelse(U < p0 + p1, 1, 2))
# 5. Montar el data.frame
df <- data.frame(
outcome = factor(y_mul, levels = 0:2, labels = c("Rechazado","Espera","Gana")),
X1 = X1,
X2 = X2
)
# 6. Estimación del modelo multinomial (mlogit)
library(nnet)
mlogit_mod <- multinom(outcome ~ X1 + X2, data = df)
summary(mlogit_mod)
stargazer(mlogit_mod)
library(stargazer)
stargazer(mlogit_mod)
stargazer(mlogit_mod, type="text")
df$outcome_ord <- ordered(df$outcome,
levels = c("Rechazado","Espera","Gana"))
ologit_mod <- polr(outcome_ord ~ X1 + X2, data = df, Hess = TRUE)
library(MASS)
# Convertimos outcome a ordered factor
df$outcome_ord <- ordered(df$outcome,
levels = c("Rechazado","Espera","Gana"))
ologit_mod <- polr(outcome_ord ~ X1 + X2, data = df, Hess = TRUE)
summary(ologit_mod)
stargazer(ologit_mod, type="text")
effect_size <- 100
# Standard deviation
sd <- 150
# Cohen's d = mean difference / SD
d <- effect_size / sd
# Sample size calculation
power.t.test(power = 0.8, sig.level = 0.05, delta = effect_size,
sd = sd, type = "two.sample", alternative = "two.sided")
effect_size <- 50
# Standard deviation
sd <- 150
# Cohen's d = mean difference / SD
d <- effect_size / sd
# Sample size calculation
power.t.test(power = 0.8, sig.level = 0.05, delta = effect_size,
sd = sd, type = "two.sample", alternative = "two.sided")
effect_size <- 75
# Standard deviation
sd <- 150
# Cohen's d = mean difference / SD
d <- effect_size / sd
# Sample size calculation
power.t.test(power = 0.8, sig.level = 0.05, delta = effect_size,
sd = sd, type = "two.sample", alternative = "two.sided")
# Load necessary libraries
library(dplyr)
library(tidyr)
library(ggplot2)
library(stargazer)
library(sandwich)   # For robust and clustered standard errors
library(lmtest)
library(lme4)
library(modelsummary)
library(tinytable)
# Load necessary libraries
library(dplyr)
library(tidyr)
library(ggplot2)
library(stargazer)
library(sandwich)   # For robust and clustered standard errors
library(lmtest)
library(lme4)
library(modelsummary)
library(tinytable)
library(rlang)
library(pandoc)
if (!requireNamespace("semPlot", quietly = TRUE)) install.packages("semPlot")
if (!requireNamespace("lavaan", quietly = TRUE)) install.packages("lavaan")
library(lavaan)
library(semPlot)
rm(list=ls())
path_github <-"C:/Users/DCCS2/Documents/GitHub/Multi-level-collective-action-in-small-scale-fisheries/Exptal Sessions/R/"
path_datos<-"C:/Users/DCCS2/Dropbox/CICS/Experiments/Islitas/Data/Sessions"
#path_github <-"C:/Users/Denise Laroze/Documents/GitHub/Multi-level-collective-action-in-small-scale-fisheries/Exptal Sessions/R/"
#path_datos<-"C:/Users/Denise Laroze/Dropbox/CICS/Experiments/Islitas/Data/Sessions"
setwd(path_github)
#load(paste0(path_datos, "/Datos_islitas.Rdata"))
load(paste0(path_datos, "/Datos_islitas_recode.Rdata"))
load(paste0(path_datos, "/Datos_islitas_long.Rdata"))
df_long_ext <- dfs_long %>%
pivot_longer(
cols = c(extraction_amerb, extraction_OA),
names_to = "area",
values_to = "extraction"
) %>%
mutate(
# simplify area labels
area = recode(
area,
extraction_amerb = "TURF",
extraction_OA    = "Shared_Area"
),
# compute compliance
compliance = 1 - (extraction / 50)
)
with(df_long_ext, {
treat.area <- paste0(area, "_", treatment)
# Define factor with desired order
treat.area <- factor(treat.area,
levels = c(
"TURF_T1", "TURF_T2",
"Shared_Area_T1", "Shared_Area_T2"
))
# Explicitly relevel to ensure baseline
treat.area <- relevel(treat.area, ref = "TURF_T1")
df_long_ext$treat.area <<- treat.area
})
### Empirical tests of H1: differences between SA in T1 and Turf in T1:
model <- lmer(compliance ~ treat.area + (1 | participant.code), data = df_long_ext)
summary(model)
names(df_long_ext)
model2 <- lmer(compliance ~ treat.area*treatment + (1 | participant.code), data = df_long_ext)
summary(model2)
model2 <- lmer(compliance ~ area*treatment + (1 | participant.code), data = df_long_ext)
summary(model2)
df_long_ext <- dfs_long %>%
pivot_longer(
cols = c(extraction_amerb, extraction_OA),
names_to = "area",
values_to = "extraction"
) %>%
mutate(
# simplify area labels
area = recode(
area,
extraction_amerb = "TURF",
extraction_OA    = "Shared_Area"
),
area <- relevel(area, ref = "TURF"),
# compute compliance
compliance = 1 - (extraction / 50)
)
df_long_ext$area <- factor(df_long_ext$area)
df_long_ext$area <- relevel(df_long_ext$area, ref = "TURF")
model2 <- lmer(compliance ~ area*treatment + (1 | participant.code), data = df_long_ext)
summary(model2)
df_long_ext$area <- factor(df_long_ext$area)
df_long_ext$area <- relevel(df_long_ext$area, ref = "TURF")
model2 <- lmer(compliance ~ area*treatment + (1 | participant.code), data = df_long_ext)
summary(model2)
my_labels <- c(
`(Intercept)`  = "Intercept (TURF rounds 1-8)",
treat.areaTURF_T2  = "Shared Area",
treat.areaShared_Area_T1    = "Known Others (rounds 9-16)",
treat.areaShared_Area_T2 = "Interactiona Area and Known others"
)
modelsummary(
model,
output    = paste0(path_github, "Outputs/LMM_H2.docx"),
stars     = TRUE,
coef_map  = my_labels
)
did_df <- df_long_ext %>%
group_by(participant.code, treat.area, round) %>%
summarise(mean_comp = mean(compliance, na.rm = TRUE), .groups = "drop") %>%
pivot_wider(
names_from = treat.area,
values_from = mean_comp
) %>%
mutate(
diff_turf   = TURF_T2 - TURF_T1,
diff_shared = Shared_Area_T2 - Shared_Area_T1,
DiD         = diff_turf - diff_shared
)
View(did_df)
t_test_did <- t.test(did_df$DiD, mu = 0)
cat("One-sample t-test for DiD ≠ 0:
")
print(t_test_did)
View(did_df)
# 9b. Wilcoxon signed-rank test (non-parametric)
wilcox_did <- wilcox.test(did_df$DiD, mu = 0)
cat("Wilcoxon signed-rank test for DiD ≠ 0:
")
print(wilcox_did)
dfs_long$round.plm<-ifelse(dfs_long$treatment=="T2", as.numeric(dfs_long$round)+8, as.numeric(dfs_long$round))
dfs_long$participant.code.plm<-ifelse(dfs_long$treatment=="T2", paste0(dfs_long$participant.code, ".T2"), dfs_long$participant.code)
modelsummary(
model2,
output    = paste0(path_github, "Outputs/LMM_H2.docx"),
stars     = TRUE,
coef_map  = my_labels
)
model2 <- lmer(compliance ~ area*treatment + (1 | participant.code), data = df_long_ext)
summary(model2)
model2 <- lmer(compliance ~ area*treatment + (1 | participant.code), data = df_long_ext)
summary(model2)
my_labels <- c(
`(Intercept)`  = "Intercept (TURF rounds 1-8)",
treat.areaTURF_T2  = "Shared Area",
treat.areaShared_Area_T1    = "Known Others (rounds 9-16)",
treat.areaShared_Area_T2 = "Area*Known Others"
)
modelsummary(
model2,
output    = paste0(path_github, "Outputs/LMM_H2.docx"),
stars     = TRUE,
coef_map  = my_labels
)
modelsummary(
model2,
output    = paste0(path_github, "Outputs/LMM_H2.docx"),
stars     = TRUE
)
modelsummary(
model2,
output    = paste0(path_github, "Outputs/LMM_H2.docx"),
stars     = TRUE
)
### Empirical tests of H2
model2 <- lmer(compliance ~ area*treatment + (1 | participant.code), data = df_long_ext)
summary(model2)
my_labels <- c(
`(Intercept)`  = "Intercept (TURF rounds 1-8)",
areaShared_Area  = "Shared Area",
treatmentT2    = "Known Others (rounds 9-16)",
`areaShared_Area × treatmentT2` = "Area*Known Others"
)
modelsummary(
model2,
output    = paste0(path_github, "Outputs/LMM_H2.docx"),
stars     = TRUE,
coef_map  = my_labels
)
### Empirical tests of H2
model2 <- lmer(compliance ~ area*treatment + (1 | participant.code), data = df_long_ext)
summary(model2)
my_labels <- c(
`(Intercept)`  = "Intercept (TURF rounds 1-8)",
areaShared_Area  = "Shared Area",
treatmentT2    = "Known Others (rounds 9-16)",
`areaShared_Area × treatmentT2` = "Area*Known Others"
)
modelsummary(
model2,
output    = paste0(path_github, "Outputs/LMM_H2.docx"),
stars     = TRUE,
coef_map  = my_labels
)
model2 <- lmer(compliance ~ area*treatment + (1 | participant.code), data = df_long_ext)
summary(model2)
my_labels <- c(
`(Intercept)`  = "Intercept (TURF rounds 1-8)",
areaShared_Area  = "Shared Area",
treatmentT2    = "Known Others (rounds 9-16)",
`areaShared_Area × treatmentT2` = "Area*Known Others"
)
modelsummary(
model2,
output    = paste0(path_github, "Outputs/LMM_H2.docx"),
stars     = TRUE
)
model2 <- lmer(compliance ~ area*treatment + (1 | participant.code), data = df_long_ext)
summary(model2)
my_labels <- c(
`(Intercept)`  = "Intercept (TURF rounds 1-8)",
areaShared_Area  = "Shared Area",
treatmentT2    = "Known Others (rounds 9-16)",
areaShared_Area:treatmentT2 = "Area*Known Others"
my_labels <- c(
`(Intercept)`  = "Intercept (TURF rounds 1-8)",
areaShared_Area  = "Shared Area",
treatmentT2    = "Known Others (rounds 9-16)",
`areaShared_Area:treatmentT2` = "Area*Known Others"
)
modelsummary(
model2,
output    = paste0(path_github, "Outputs/LMM_H2.docx"),
stars     = TRUE,
coef_map  = my_labels
)
# Fit models (yours):
model  <- lmer(compliance ~ treat.area + (1 | participant.code), data = df_long_ext)
model2 <- lmer(compliance ~ area * treatment + (1 | participant.code), data = df_long_ext)
# One coef map covering ALL terms that appear in either model (order = row order)
coef_map <- c(
"(Intercept)"                      = "Intercept (TURF rounds 1–8)",
"treat.areaTURF_T2"                = "TURF rounds 9–16 (dummy)",
"treat.areaShared_Area_T1"         = "Shared Area Unknown Out-group (dummy)",
"treat.areaShared_Area_T2"         = "Shared Area Known Out-group (dummy)",
"areaShared_Area"                  = "Shared Area",
"treatmentT2"                      = "Known Others (rounds 9–16)",
"areaShared_Area:treatmentT2"      = "Area × Known Others"
)
# Model names for columns
models <- list(
"H1: TURF vs SA (T1)"     = model,
"H2: Area × Treatment"    = model2
)
modelsummary(
models,
coef_map   = coef_map,
# optional: keep only the mapped rows (drop any stray contrasts)
coef_omit  = "^$",
stars      = TRUE,
statistic  = "({std.error})",
gof_omit   = "IC|Log|RMSE",  # hide AIC/BIC/LogLik if you want a cleaner table
title      = "Empirical tests of H1 & H2 (LMM with random intercept by participant)",
output     = paste0(path_github, "Outputs/LMM_H1_H2.docx")
)
# Base table
tab <- modelsummary(
models,
coef_map   = coef_map,
coef_omit  = "^$",
stars      = TRUE,
statistic  = "({std.error})",
gof_omit   = "IC|Log|RMSE",
output     = "data.frame"
)
# Add a line before Num.Obs
line_before <- data.frame(term = " ", stringsAsFactors = FALSE)
tab <- rbind(
tab[1:(nrow(tab)-1), ],  # all but last row
line_before,             # blank row (acts like a separator in DOCX)
tab[nrow(tab), ]         # Num.Obs row
)
model  <- lmer(compliance ~ treat.area + (1 | participant.code), data = df_long_ext)
model2 <- lmer(compliance ~ area * treatment + (1 | participant.code), data = df_long_ext)
# One coef map covering ALL terms that appear in either model (order = row order)
coef_map <- c(
"(Intercept)"                      = "Intercept (TURF rounds 1–8)",
"treat.areaTURF_T2"                = "TURF rounds 9–16 (dummy)",
"treat.areaShared_Area_T1"         = "Shared Area Unknown Out-group (dummy)",
"treat.areaShared_Area_T2"         = "Shared Area Known Out-group (dummy)",
"areaShared_Area"                  = "Shared Area (dummy)",
"treatmentT2"                      = "Known Out-group condition (dummy)",
"areaShared_Area:treatmentT2"      = "Area × Known Out-group"
)
# Model names for columns
models <- list(
"H1: TURF vs Shared Area"     = model,
"H2: Area × Known Out-group condition"    = model2
)
modelsummary(
models,
coef_map   = coef_map,
# optional: keep only the mapped rows (drop any stray contrasts)
coef_omit  = "^$",
stars      = TRUE,
statistic  = "({std.error})",
gof_omit   = "IC|Log|RMSE",  # hide AIC/BIC/LogLik if you want a cleaner table
title      = "Empirical tests of H1 & H2 (LMM with random intercept by participant)",
output     = paste0(path_github, "Outputs/LMM_H1_H2.docx")
)
modelsummary(
models,
coef_map   = coef_map,
# optional: keep only the mapped rows (drop any stray contrasts)
coef_omit  = "^$",
stars      = c('*' = 0.05, '**' = 0.01, '***' = 0.001),
statistic  = "({std.error})",
gof_omit   = "IC|Log|RMSE",  # hide AIC/BIC/LogLik if you want a cleaner table
title      = "Empirical tests of H1 & H2 (LMM with random intercept by participant)",
output     = paste0(path_github, "Outputs/LMM_H1_H2.docx")
)
summary(model2)
summary(model)
# Load necessary libraries
library(dplyr)
library(tidyr)
library(ggplot2)
library(stargazer)
library(sandwich)   # For robust and clustered standard errors
library(lmtest)
library(lme4)
library(modelsummary)
library(tinytable)
library(rlang)
library(pandoc)
if (!requireNamespace("semPlot", quietly = TRUE)) install.packages("semPlot")
if (!requireNamespace("lavaan", quietly = TRUE)) install.packages("lavaan")
library(lavaan)
library(semPlot)
rm(list=ls())
path_github <-"C:/Users/DCCS2/Documents/GitHub/Multi-level-collective-action-in-small-scale-fisheries/Exptal Sessions/R/"
path_datos<-"C:/Users/DCCS2/Dropbox/CICS/Experiments/Islitas/Data/Sessions"
#path_github <-"C:/Users/Denise Laroze/Documents/GitHub/Multi-level-collective-action-in-small-scale-fisheries/Exptal Sessions/R/"
#path_datos<-"C:/Users/Denise Laroze/Dropbox/CICS/Experiments/Islitas/Data/Sessions"
setwd(path_github)
#load(paste0(path_datos, "/Datos_islitas.Rdata"))
load(paste0(path_datos, "/Datos_islitas_recode.Rdata"))
load(paste0(path_datos, "/Datos_islitas_long.Rdata"))
df_long_ext <- dfs_long %>%
pivot_longer(
cols = c(extraction_amerb, extraction_OA),
names_to = "area",
values_to = "extraction"
) %>%
mutate(
# simplify area labels
area = recode(
area,
extraction_amerb = "TURF",
extraction_OA    = "Shared_Area"
),
# compute compliance
compliance = 1 - (extraction / 50)
)
with(df_long_ext, {
treat.area <- paste0(area, "_", treatment)
# Define factor with desired order
treat.area <- factor(treat.area,
levels = c(
"TURF_T1", "TURF_T2",
"Shared_Area_T1", "Shared_Area_T2"
))
# Explicitly relevel to ensure baseline
treat.area <- relevel(treat.area, ref = "TURF_T1")
df_long_ext$treat.area <<- treat.area
})
df_long_ext$area <- relevel(factor(df_long_ext$area), ref = "TURF")
### Empirical tests of H1 and H2: differences between SA in T1 and Turf in T1 and T2:
# Fit models (yours):
model  <- lmer(compliance ~ treat.area + (1 | participant.code), data = df_long_ext)
model2 <- lmer(compliance ~ area * treatment + (1 | participant.code), data = df_long_ext)
# One coef map covering ALL terms that appear in either model (order = row order)
coef_map <- c(
"(Intercept)"                      = "Intercept (TURF rounds 1–8)",
"treat.areaTURF_T2"                = "TURF rounds 9–16 (dummy)",
"treat.areaShared_Area_T1"         = "Shared Area Unknown Out-group (dummy)",
"treat.areaShared_Area_T2"         = "Shared Area Known Out-group (dummy)",
"areaShared_Area"                  = "Shared Area (dummy)",
"treatmentT2"                      = "Known Out-group condition (dummy)",
"areaShared_Area:treatmentT2"      = "Area × Known Out-group"
)
# Model names for columns
models <- list(
"H1: TURF vs Shared Area"     = model,
"H2: Area × Known Out-group condition"    = model2
)
df_long_ext <- dfs_long %>%
pivot_longer(
cols = c(extraction_amerb, extraction_OA),
names_to = "area",
values_to = "extraction"
) %>%
mutate(
# simplify area labels
area = recode(
area,
extraction_amerb = "TURF",
extraction_OA    = "Shared_Area"
),
# compute compliance
compliance = 1 - (extraction / 50)
)
with(df_long_ext, {
treat.area <- paste0(area, "_", treatment)
# Define factor with desired order
treat.area <- factor(treat.area,
levels = c(
"TURF_T1", "TURF_T2",
"Shared_Area_T1", "Shared_Area_T2"
))
# Explicitly relevel to ensure baseline
treat.area <- relevel(treat.area, ref = "TURF_T1")
df_long_ext$treat.area <<- treat.area
})
df_long_ext$area <- relevel(factor(df_long_ext$area), ref = "TURF")
### Empirical tests of H1 and H2: differences between SA in T1 and Turf in T1 and T2:
# Fit models (yours):
model  <- lmer(compliance ~ treat.area + (1 | participant.code), data = df_long_ext)
model2 <- lmer(compliance ~ area * treatment + (1 | participant.code), data = df_long_ext)
# One coef map covering ALL terms that appear in either model (order = row order)
coef_map <- c(
"(Intercept)"                      = "Intercept (TURF rounds 1–8)",
"treat.areaTURF_T2"                = "TURF rounds 9–16 (dummy)",
"treat.areaShared_Area_T1"         = "Shared Area Unknown Out-group (dummy)",
"treat.areaShared_Area_T2"         = "Shared Area Known Out-group (dummy)",
"areaShared_Area"                  = "Shared Area (dummy)",
"treatmentT2"                      = "Known Out-group condition (dummy)",
"areaShared_Area:treatmentT2"      = "Area × Known Out-group"
)
# Model names for columns
models <- list(
"H1: TURF vs Shared Area"     = model,
"H2: Area × Known Out-group condition"    = model2
)
modelsummary(
models,
coef_map   = coef_map,
# optional: keep only the mapped rows (drop any stray contrasts)
coef_omit  = "^$",
stars      = c('*' = 0.05, '**' = 0.01, '***' = 0.001),
statistic  = "({std.error})",
gof_omit   = "IC|Log|RMSE",  # hide AIC/BIC/LogLik if you want a cleaner table
title      = "Empirical tests of H1 & H2 (LMM with random intercept by participant)",
output     = paste0(path_github, "Outputs/LMM_H1_H2_2.docx")
)
